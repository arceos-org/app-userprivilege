use std::path::PathBuf;

fn main() {
    // Only apply bare-metal linker settings when targeting a no_std platform.
    // This allows `cargo publish` verification (which builds for the host) to succeed.
    let target = std::env::var("TARGET").unwrap_or_default();
    if !target.contains("-none") {
        return;
    }

    // The linker script is generated by axhal's build.rs at:
    //   target/<target_triple>/<profile>/linker_<platform>.lds
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let profile_dir = PathBuf::from(&out_dir).join("../../..");
    let profile_dir = std::fs::canonicalize(&profile_dir)
        .unwrap_or_else(|_| PathBuf::from(&out_dir).join("../../.."));

    let arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap();
    let platform = match arch.as_str() {
        "riscv64" => "riscv64-qemu-virt",
        "aarch64" => "aarch64-qemu-virt",
        "x86_64" => "x86-pc",
        "loongarch64" => "loongarch64-qemu-virt",
        other => panic!("Unsupported architecture: {other}"),
    };
    let lds_path = profile_dir.join(format!("linker_{platform}.lds"));

    println!("cargo:rustc-link-arg=-T{}", lds_path.display());
    println!("cargo:rustc-link-arg=-no-pie");
    println!("cargo:rustc-link-arg=-znostart-stop-gc");
}
